# Core format { #core-format }

## General { #fileFormat-General }

A SARIF log file shall contain the results of a one or more analysis runs.
The runs need not be produced by the same analysis tool.

A SARIF log file shall conform to the requirements of the JSON format.
The top-level value in the log file shall conform to the JSON object grammar;
that is, it shall consist of a comma-separated sequence of name/value pairs, enclosed in curly brackets,
as described in the JSON specification.
We refer to the object represented by this top-level value as the `sarifLog` object (&sect;[#sarifLog]).

Because SARIF conforms to the JSON format, all integer values shall be expressed in decimal notation.
Hexadecimal or octal notation shall not be used.

Every JSON property name defined by the SARIF format shall be a camelCase name.
Because the names of properties defined in property bags (&sect;[#property-bag-properties]) such as `result.properties` (&sect;[#result-properties]),
are not defined by the SARIF format, they are not subject to this requirement.
These property names should also be camelCase, but see [Annex C](#Annex-C) for exceptions.

~ IsoNote
A single run of an analysis tool that supports the SARIF format produces a SARIF log file
containing the results of that one run.
Other programs, such as build systems or result management systems, can consolidate the contents
of multiple single-run log files into a single SARIF log file that contains the results from all of those runs.
This allows the aggregated results to be conveniently stored in a file or transported over a network.
~

## URI-valued properties { #uriProperties }

Certain properties in this specification specify the URI of a file.
The value of every such property, if present, shall be a valid URI as described in RFC 3986.

If a URI refers to a file stored in a version control system (VCS),
the value shall preserve relevant details that permit the target file to be retrieved from the VCS.
If the URI refers to a file stored on a physical file system, it may be specified as a relative URI
that omits root information details
(such as hard drive letter and an arbitrarily named root directory associated with a source code enlistment).

~ IsoNote
An absolute URI may contain information that represents unwanted information disclosure,
particularly in cases where a tool is analyzing files stored on a physical file system.
For example, a file path might contain the account name of a developer.
~

Two URIs shall be considered equivalent if their normalized forms are the same
as described in RFC 3986.

~ IsoNote
For example, in the normalized form specified in RFC 3986:

* Percent-encoded characters use upper-case hexadecimal digits.
* Characters in the ALPHA and DIGIT ranges are not be percent-encoded,
nor are hyphen, underscore, or tilde.
* The ":" delimiter is omitted if the port component of the authority is empty.
* In the host component, registered names and hexadecimal addresses use lower-case.
~

## Tag set properties

Certain properties in this specification are defined to be "tag sets".
A tag set is a JSON array containing zero or more arbitrary strings;
no element of the array shall be a number, an array, or an object.
No two of the strings shall be the same.
Two strings shall be considered the same if they consist of the same
sequence of Unicode code points.

## Property bag properties { #property-bag-properties }

Certain properties in this specification are defined to be "property bags".
A property bag is a JSON object.
The names of the properties within this JSON object should be camelCase strings,
but see [Annex C](#Annex-C) for exceptions.
The values of the properties shall be arbitrary strings; they shall not be numbers, arrays, or sub-objects.

## Date/time properties { #fileFormat-dateTime }

Certain properties in this specification specify a date and time.
The value of every such property, if present, shall be a string in the following format,
which is compatible with [ISO-8601:2004](http://www.iso.org/iso/catalogue_detail?csnumber=40874)

```
<dateTime>: <date>T<time>Z

<date>:     YYYY-MM-DD

<time>:     hh:mm:ss[.sss]
```

Here `YYYY` is a 4-digit year,
`MM` is a 2-digit month from 01 to 12,
`DD` is a 2-digit day from 01 to 31,
`T` is a literal character "T" separating the date from the time,
`hh` is a 2-digit hours from 00 to 23,
`mm` is a 2-digit minutes from 00 to 59,
`ss` is a 2-digit seconds from 00 to 59,
`[.sss]` is an optional 3-digit number of milliseconds from 000 to 999, and
`Z` is a literal character "Z" specifying UTC time.

~ IsoExample

```
2016-02-08T16:08:25Z
2016-02-08T16:08:25.943Z
```
~

## `sarifLog` object { #sarifLog }

### General { #sarifLog-General }

An `sarifLog` object specifies the version of the file format and contains the output from one or more runs.

~ IsoExample

```
{
    "version" : "0.1",  # see \(&sect;[#sarifLog-version]\)
    "runs" :            # see \(&sect;[#sarifLog-runs]\)
    [
        {
            ...         # a run object (see \(&sect;[#run]\))
        },
        ...
        {
            ...         # another run object
        }
    ]
}
```
~

### `version` property { #sarifLog-version }

A `sarifLog` object shall contain a property named `version` whose value is the string `"1.0.0-beta.2"`.

Although the order in which the name/value pairs appear in a JSON object value is not semantically significant,
the `version` property should appear first. 
~ IsoNote
This will make it easier for parsers to handle multiple versions of the SARIF format,
if new versions are defined in the future.
~

~ IsoNote
The value of this property, in the version of SARIF described by
this document and in all future versions of the SARIF standard, will be in the format specified by Semantic
Versioning 2.0.0
~

### `runs` property { #sarifLog-runs }

An `sarifLog` object shall contain a property named `runs` whose value is an array
of one or more `run` objects (&sect;[#run]).

## `run` object { #run }

### General { #run-General }

A `run` object describes a single run of an analysis tool,
and contains the output of that run.

~ IsoExample

```
{
    "tool":        # see \(&sect;[#run-tool]\)
    {
        ...        # a tool object (see \(&sect;[#tool]\))
    },
    "results":     # see \(&sect;[#run-results]\)
    [
        {
            ...    # a result object (see \(&sect;[#result]\))
        },
        ...
        {
            ...    # another result object
        }
    ]
}
```
~

### `tool` property { #run-tool }

A `run` object shall contain a property named `tool` whose value is a `tool` object (&sect;[#tool]).


### `invocation` property { #run-invocation }

A `run` object may contain a property named `invocation` whose value is a string
containing the runtime parameters with which the tool was invoked.
For command line tools, this string may consist of the completely specified command line used to invoke the tool.

~ IsoNote
The information in the `invocation` property makes it possible to precisely repeat a run of an analysis tool,
and to verify that the results reported in the log file were generated by an appropriate invocation of the tool.
~

If the invocation information contains information which should not be disclosed,
such as passwords, tokens, database connection strings, or in some circumstances even the fully qualified path to
the tool executable, that information should be redacted or omitted.
Redacted information should be replaced with the token `[REMOVED]`.

~ IsoExample
Suppose a tool is invoked with the command line

```
    C:\Users\johnsmith\Tools\DbScanner\DbScanner.exe
        /ConnectionString "Server=CorpServer;Database=Accounting;User Id=Admin;Password=S3cr#t" /input *.sql
```

Then the value of the `invocation` property might contain the redacted command line

```
    [REMOVED]\DbScanner.exe /connectionString=[REMOVED] /input=*.sql 
```
~

~ IsoNote
Redacting sensitive information from `invocation` makes it more difficult to precisely reproduce
an analysis run. The value of `invocation` would have to be combined with information from another
source to allow the run to be repeated.
~

### `files` property { #run-files }

A `run` object should contain a property named `files` whose value is a JSON object,
each of whose properties represents a file that was scanned in the course of the run.

Each property name in the `files` object shall be the URI of a scanned file.
No two of these property names shall be equivalent as defined in &sect;[#uriProperties].

Each property value in the `files` object shall be an array of `file` objects (&sect;[#file])
which contain information about the file identified by the URI in the property name.

The object specified by the `files` property should contain properties representing at least those files in which results were detected,
but it may contain properties representing all scanned files (whether or not results were detected in those files),
or for any subset of those files.

~ IsoNumberedNote { @IsoNumberedNote=1}
`file` objects contain information that is useful for viewers.
Viewers will be able to provide the most information to users if the `files`
property is present and contains information for every file in which results were detected.
~

If the scanned file is not nested within another file, then the array shall consist of a single
element, and the property name shall be the URI of the scanned file.
If the absolute location of the scanned file is available, the URI should be an absolute URI;
otherwise, the URI shall be a relative URI.

~ IsoNumberedExample { @IsoNumberedExample=1}

```
run: {
    files: {
        "file:///C:/Code/main.cc": [
            {
                "mimeType": "text/x-c",
                "hashes": [
                    {
                        "value": "b13ce2678a8807ba0765ab94a0ecd394f869bc81",
                        "algorithm": "SHA-256"
                    }
                ]
            }
        ]
    }
}
```
~

If the scanned file is nested within another file (for example, within a compressed container),
then the first `file` object in the array shall refer to the outermost container,
the next one shall refer to a file nested immediately within that container, and so on,
with the last element of the array referring to the most deeply nested file.

In this case, the property name shall be the absolute URI of the outermost containing
file, together with a fragment that describes the nesting of the scanned file within
its parent or parents.
If the scanned file is nested more than one level deep in the outermost containing file,
the fragments representing each level of nesting may be combined in any way desired,
as long as no two of the resulting property names are equivalent as defined in &sect;[#uriProperties].

~ IsoNumberedNote
It need not be possible to use this URI to navigate directly to the nested scanned file.
The information necessary to do that is specified in the `uri` property (&sect;[#file-uri]),
or in the `offsetFromParent` (&sect;[#file-offsetFromParent]) and `length` (&sect;[#file-length]) properties,
of the `file` objects in the array .
~

~ IsoNumberedExample
Suppose a result is detected within a Flash object contained in a word processing document which is in turn contained
in a compressed archive.
Suppose the path to the word processing document within the compressed archive is `/docs/intro.docx`.
Then one possible value for the property name within the `files` object would be:

```
file:///C:/Code/presentation.zip#/docs/intro.docx/Flash1
```
~

If the fragment contains any characters which cannot occur in a fragment as specified in RFC 3986,
those character must be percent-encoded as specified in RFC 3986.

~ IsoNumberedExample
Suppose a compressed container contains a file named `/docs/chapter#1.doc`.
Then one possible value for the property name within the `files` object would be:

```
file:///C:/Code/presentation.zip#/docs/chapter%231.doc
```
The `#` character has been percent-encoded as `%23`.
~

~ IsoNumberedExample
This example shows a `files` property that represents a file nested two levels deep in its
outermost container.
The first level of nesting is specified by a path within a compressed container.
The second level of nesting is specified by a byte offset from the start of the container,
together with a length. See &sect;[#file]. 

```
run: {
    files: {
        "file:///C:/Code/app.zip#/docs/intro.docx/Flash1": [
            {
                "mimeType": "application/zip",
            },
            {
                "uri": "/docs/intro.docx"
                "mimeType": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
            },
            {
                "offsetFromParent": 17522,
                "length": 4050,
                "mimeType": "application/x-shockwave-flash"
            }
        ]
    }
}
```
~

### `logicalLocations` property { #run-logicalLocations }

A `run` object should contain a property named `logicalLocations` whose value is a dictionary,
each of whose properties represents the logical location of one or more results produced in the course of the run.

With one exception described in &sect;[#location-logicalLocationKey], each property name in the `logicalLocations` object shall be
a string representing the logical location where the result was produced, in a format consistent with
the programming language in which the programmatic construct specified by that logical location was expressed.
We refer to this string as a "fully qualified logical name".
See &sect;[#location-fullyQualifiedLogicalName] for examples.

Each value in the `logicalLocation` object shall be
an array of one or more `logicalLocationComponent` objects (&sect;[#logicalLocationComponent]).
This allows reference to results which occur in nested logical components, for example,
a member nested within a type which is in turn nested within a namespace.
When a result occurs in such a nested construct, the first `logicalLocationComponent` object in the array shall refer to
the outermost construct,
the next element shall refer to a construct nested immediately within the first construct,
and so on, with the last element referring to the most deeply nested construct.

~ IsoExample

```
"logicalLocations": {
  "namespaceA::namespaceB::classC": [
    {
      "name": "namespaceA",
      "kind": "namespace"
    },
    {
      "name": "namespaceB",
      "kind": "namespace"
    },
    {
      "name": "classC",
      "kind": "type"
    }
  ]
}
```
~

~ IsoNote
The reason that the detailed information in `logicalLocations` is useful,
even though much of the information it contains is captured in the `location.fullyQualifiedLogicalName` property (&sect;[#location-fullyQualifiedLogicalName]),
is that it allows results management systems and other programs to organize
analysis results, for example, by asking questions such as "How many results were
found in the class `NamespaceA.NamespaceB.ClassC`?".
Programs can ask these questions without having to know how to parse the `fullyQualifiedLogicalName` string.
~

### `results` property { #run-results }

If the analysis tool was run with the intent of scanning files and producing results, then
the `run` object shall contain a property named `results` whose value is an array containing zero or more `result` objects (&sect;[#result]),
each of which represents a single result produced in the course of the run.

The `results` array shall be empty if the run that produced the `run` object did not produce any results.

If the tool was run solely for the purpose of exporting rule metadata (see &sect;[#run-rules]),
the `results` property shall be absent.

### `rules` property { #run-rules }

A `run` object (&sect;[#run]) may contain a property named `rules`
whose value is a JSON object, each of whose properties represents an analysis rule.

Each property name in the `rules` object shall be the id of an analysis rule.

Each property value in the `rules` object shall be a `rule` object (&sect;[#rule]) whose
`id` property (&sect;[#rule-id]) is equal to the property name.

~ IsoNote
This property is a dictionary, rather than simply an array of `rule` objects,
to facilitate looking up the rule associated with each `result` object (&sect;[#result])
by means of the `result`'s `ruleId` property (&sect;[#result-ruleId]).
~

### `tags` property { #run-tags }

A `run` object may contain a property named `tags`, whose value is a tag set.

### `properties` property { #run-properties }

A `run` object may contain a property named `properties`, whose value is property bag.
This allows tools to include information about the run that is not explicitly specified in the SARIF format.

## `tool` object { #tool }

### General { #tool-General }

A `tool` object contains information describing the analysis tool that was run.

~ IsoNote
If another tool post-processes the log file (for example, by removing certain results,
or by adding information that was not known to the analysis tool),
the post-processing tool should not alter any part of the `tool` object.
~

~ IsoExample

```
{
    "name": "CodeScanner",                                       # see \(&sect;[#tool-name]\)
    "fullName": "CodeScanner 1.1, Developer Preview (en-US)",    # see \(&sect;[#tool-fullName]\)
    "semanticVersion": "1.1.2-beta.12",                          # see \(&sect;[#tool-semanticVersion]\)
    "version": "1.1.2b12,                                        # see \(&sect;[#tool-version]\)
    "fileVersion": "1.1.1502.2"                                  # see \(&sect;[#tool-fileVersion]\)
}
```
~

### `name` property { #tool-name }

A `tool` object shall contain a property named `name` whose value is a string containing the name of the tool that produced the log file.

~ IsoExample
`"CodeScanner"`
~

### `fullName` property { #tool-fullName }

A `tool` object may contain a property named `fullName` whose value is a string containing the name of the tool
along with its version and any other useful identifying information, such as its locale.

~ IsoExample
`"CodeScanner 1.1, Developer Preview (en-US)"`
~

### `semanticVersion` property { #tool-semanticVersion }

In a log file produced by an analysis tool, a `tool` object shall contain a property named `semanticVersion`
whose value is a string containing the tool version in the format specified by Semantic Versioning 2.0.0 ("SemVer").

~ IsoNumberedExample { @IsoNumberedExample=1 }
`"1.1.2-beta.12"`
~

~ IsoNumberedNote { @IsoNumberedNote=1 }
Semantic versions have the property of being sortable in chronological order of release.
The presence of the `semanticVersion` property allows results management systems to (for example)
restrict the results they display to versions newer than a specified version,
or to restrict the results to a particular major version.
~

If the tool does not natively present its version string in SemVer format,
it shall synthesize a SemVer string to populate the `semanticVersion` property. 

~ IsoNumberedExample
Suppose an analysis tool natively presents its version string as `"2.0"`
(no "patch level" is available). The tool would synthesize a SemVer string `"2.0.0"`.
~

~ IsoNumberedExample
Suppose an analysis tool natively presents its version string as `"1.1.2b12"`
(the "pre-release" information is not in SemVer format).
The tool would synthesize a SemVer string `"1.1.2-beta.12"`.
~

In a log file produced by a conversion tool, the `semanticVersion` property shall be absent.

~ IsoNumberedNote
The rationale is that an analysis tool knows whether its version string is intended to be
interpreted according to SemVer.
A converter will in general not know this, even if the tool's version string conforms to the
pattern specified by SemVer.
~

### `version` property { #tool-version }

In a log file produced by an analysis tool, a `tool` object may contain a property named `version`
whose value is a string containing the tool version in whatever format the tool natively provides.

In a log file produced by a converter, the `version` property shall be present.

### `fileVersion` property { #tool-fileVersion }

If the operating system on which the tool runs provides a value for the file version of the tool's primary executable file,
then the `tool` object may contain a property named `fileVersion` whose value is
a string representation of that file version.
If the operating system does not provide such a value, the `fileVersion` property shall be absent.

~ IsoExample
On the Windows platform, this information is available in the `FILEVERSION` member of the `VERSIONINFO` structure.
~

### `tags` property { #tool-tags }

A `tool` object may contain a property named `tags`, whose value is a tag set.

### `properties` property { #tool-properties }

A `tool` object may contain a property named `properties`, whose value is property bag.
This allows tools to include information about the themselves that is not explicitly specified in the SARIF format.

## `file` object { #file }

### General { #file-General }

A `file` object represents a single file. In some cases, this file might be nested within another file,
referred to as the "containing file."

`file` objects occur as members of arrays within the `run.files` object (&sect;[#run-files]). 

If the `file` object does not represent a nested file, neither of the properties
`uri` (&sect;[#file-uri]) or `offsetFromParent` (&sect;[#file-offsetFromParent]) shall be present.

If the location of a nested file can be expressed either by means of a path within the containing file
or by means of a byte offset from the start of the containing file, then either `uri`
or `offsetFromParent` (&sect;[#file-offsetFromParent]) or both shall be present; they must not both be absent.

### `uri` property { #file-uri }

Depending on the circumstances, a `file` object either shall or may contain a property named `uri`
whose value is a string.

If the `file` object represents a top-level file (that is, a file that is not nested within another file),
then the `uri` property may be present.
If present, it shall be equal to the name of the property within `run.files` (&sect;[#run-files])
within which the `file` object occurs, but with any URI fragment removed.
If absent, it shall be interpreted as being equal to the value it would be required to have if it were present.

If the `file` object represents a nested file, and if the location of the nested file
within its containing file can be expressed by means of a path within its containing file,
then the `uri` property shall be present, and its value shall be a valid relative URI expressing that path.

If the location of the nested file within its containing file cannot be expressed by means of a path,
then the `uri` property shall be absent.

~ IsoNumberedExample { @IsoNumberedExample = 1 }
The property name includes a fragment.
The `uri` for the top-level file (the first array element) repeats the property name without the fragment.
The `uri` for the nested file (the second array element) specifies the relative URI of the nested file
with respect to its parent.
```
"files": {
  "http://www.example.com/a.zip#/src/file.c": [
    {
      "uri": "http://www.example.com/a.zip",
      "mimeType": "application/zip"
    },
    {
      "uri": "/src/file.c",
      "mimeType": "x-c"
    }
  ]
}
```
~

~ IsoNumberedExample
The top-level `uri` is omitted. It is interpreted as `"http://www.example.com/a.zip"`.
```
"files": {
  "http://www.example.com/a.zip#/src/file.c": [
    {
      "mimeType": "application/zip"
    },
    {
      "uri": "/src/file.c",
      "mimeType": "x-c"
    }
  ]
}
```
~

The value of the `uri` property for a nested file need not match the value of the fragment
portion of the URI specified in the property name.
This allows multiple levels of nesting to be represented.

~ IsoNumberedExample
There are two levels of nesting.
Neither of the `uri` properties representing the nested files
(the second and third array elements) match the fragment portion of the URI specified in the property name.
```
"files": {
  "http://www.example.com/a.zip#/media/b.zip/images/c.png": [
    {
      "mimeType": "application/zip"
    },
    {
      "uri": "/media/b.zip",
      "mimeType": "application/zip"
    },
    {
      "uri": "/images/c.png",
      "mimeType": "image/png"
    }
  ]
}
```
~

### `offsetFromParent` property { #file-offsetFromParent }

If the location of a nested file within its containing file can be expressed
only by means of a byte offset from the start of the containing file,
then the `file` object shall contain a property named `offsetFromParent`
whose value is an integer specifying that offset.

If the location of the file within its containing file can be expressed both by means of a path
and by means of a byte offset, then the `offsetFromParent` property may be present.

If the location of the file within its containing file cannot be expressed by means of a byte offset,
then the `offsetFromParent` property shall be absent.

### `length` property { #file-length }

A `file` object may contain a property named `length`
whose value is an integer specifying the length of the file in bytes.

### `mimeType` property { #file-mimeType }

A `file` object should contain a property named `mimeType` whose value is a string that specifies
the MIME type (RFC 2045) of the file.

### `hashes` property { #file-hashes }

A `file` object may contain a property named `hashes` whose value is an array of `hash` objects (&sect;[#hash]),
each of which specifies a hashed value for the file specified by the `file` object,
along with the name of the algorithm used to compute the hash.

If present, the array specified by `hashes` shall not be empty.

~ IsoNote
A hash value for an analysis target can be useful when a log file is processed by a result management system.
The value may be used as a key when persisting results in a database.
This allows a build system to use cached results, rather than repeating the analysis, when a target has not changed.
A file hash may also be useful for validating results in a policy compliance system,
allowing an auditor to validate that rerunning analysis against a target that hashes to a specific value reproduces the provided results.

The `file` object defines an array of hash values, rather than a single hash value,
to allow a log file to be consumed by multiple tool chains that might expect hash values produced by differing algorithms.
Compliance systems, for example, will favor the use of secure hash algorithms (such as SHA-256)
that minimize the possibility that two different targets will produce the same hash (at the expense of speed to produce the hash). 
In situations where compliance and security are not a concern, a system might prefer to use a fast hash algorithm (such as MD5 or SHA-1)
that occasionally produces hash collisions.

To populate the `hashes` property, an analysis tool must support the ability to produce hashes for its analysis targets.
Alternatively, the hashes could be added to the log file as a post-processing step.

To make the best use of such an analysis tool, a user (such as a build engineer) would determine what systems
in their build environment will consume the log file.
The user would then configure the tool to produce hashes using the algorithms required by those systems.
Analysis tools that are configurable to produce hashes with a variety of commonly used algorithms
will interoperate most easily with such systems.
~

### `tags` property { #file-tags }

A `file` object may contain a property named `tags`, whose value is a tag set.

### `properties` property { #file-properties }

A `file` object may contain a property named `properties`, whose value is property bag.
This allows tools to include information about the file that is not explicitly specified in the SARIF format.

## `hash` object { #hash }

### General { #hash-General }

A `hash` object represents a hash value of some file or collection of files, together with the algorithm used to compute the hash.

~ IsoExample

```
{
    "value":"b13ce2678a8807ba0765ab94a0ecd394f869bc81",   # see \(&sect;[#hash-value]\)
    "algorithm":"SHA-256"                                 # see \(&sect;[#hash-algorithm]\)
}
```
~

### `value` property { #hash-value }

A `hash` object shall contain a property named `value` whose value is the hash value of some file or collection of files,
computed by the algorithm named in the `algorithm` property (&sect;[#hash-algorithm]). 

### `algorithm` property { #hash-algorithm }

A `hash` object shall contain a property named `algorithm`, whose value is a string specifying the name
of the algorithm used to compute the hash value specified in the `value` property (&sect;[#hash-value]).
This shall be one of the following:

*	`BLAKE-256`
*	`BLAKE-512`
*	`ECOH`
*	`FSB`
*	`GOST`
*	`Groestl`
*	`HAS-160`
*	`HAVAL`
*	`JH`
*	`MD2`
*	`MD4`
*	`MD5`
*	`MD6`
*	`RadioGatun`
*	`RIPEMD`
*	`RIPEMD-128`
*	`RIPEMD-160`
*	`RIPEMD-320`
*	`SHA-1`
*	`SHA-224`
*	`SHA-256`
*	`SHA-384`
*	`SHA-512`
*	`SHA-3`
*	`Skein`
*	`Snefru`
*	`Spectral Hash`
*	`SWIFFT`
*	`Tiger`
*	`Whirlpool`

## `result` object { #result }

### General { #result-General }

A `result` object describes a single result produced by an analysis tool.

### `ruleId` property { #result-ruleId }

A `result` object should contain a property named `ruleId` whose value is a string containing
the stable, opaque identifier for the rule that was evaluated to produce the result.

~ IsoExample
`"CA2101"`
~

Analysis tools that produce the SARIF format shall provide a `ruleId` for each `result`
(with the possible exception of `result`s whose `kind` property is `note`; see (&sect;[#result-kind]).

Not all existing analysis tools emit the equivalent of a `ruleId` in their output.
A conversion tool which converts the output of such an analysis tool to the SARIF format
shall omit `ruleId` from the `result`s.

### `kind` property { #result-kind }

A `result` object may contain a property named `kind` whose value is one of a fixed set of strings
that specify the category of the result.

If present, the `kind` property shall have one of the following values, with the specified meanings:

* `pass`: The rule specified by the `ruleId` property (&sect;[#result-ruleId]) was evaluated, and no problem was found.

* `warning`: The rule specified by the `ruleId` property was evaluated, and a problem was found.

* `error`: The rule specified by the `ruleId` property was evaluated, and a serious problem was found.

* `notApplicable`: The rule specified by the `ruleId` property was not evaluated, because it does not apply to the
file specified by `analysisTarget` (&sect;[#location-analysisTarget]).

~ IsoExample
A binary checker might have a rule that applies to 32-bit binaries only.
Such a tool would produce a `notApplicable` result if it were run on a 64-bit binary.
~

* `configurationError`: The tool encountered a rule configuration error.

    The `ruleId` property for a `result` object whose `kind` property is `configurationError` should be
    set to a unique value, distinct from the id of all other rules known to that tool, which indicates that
    an error occurred while reading rule configuration information.

~ IsoNote
Many tools can be parameterized with information about which rules to run, and how they should be configured.
In some cases, if the configuration information is invalid, the tool can ignore the invalid information
and continue to run.
~

~ IsoExample
Suppose a tool is invoked with a configuration file which specifies that the tool should disable rule X.
If there is no such rule as rule X, then the tool should report a `configurationError`. The tool might
continue to run, reporting results for the rules that are correctly configured.
~

* `internalError`: The tool encountered an internal error that prevented it from performing a complete analysis.

    If the error occurred in the course of evaluating a specific rule, the `ruleId` property should either specify that rule,
    or it should specify a unique value, distinct from the id of all other rules known to that tool, which indicates that
    an error occurred during rule evaluation.

    If the error did not occur in the course of evaluating a specific rule, the `ruleId` property should be set to a unique value,
    distinct from the id of all other rules known to that tool, which indicates that an internal tool error occurred.

~ IsoNote
Depending on the nature of the error, the tool might or might not be able to continue running.
In all cases, the presence of a `result` object whose `kind` property is set to `internalError` indicates
that the run failed, because it could could not successfully run all specified rules on all specified
analysis targets.

If a tool encounters an error in the course of evaluating a rule, the tool might report the error, disable the rule,
and continue to execute the remaining rules.

If a tool encounters an error outside of the evaluation of a rule, the tool might report
the error to the log and halt. (The tool might also just exit, either normally or abnormally.)
~

* `note`: A purely informational log entry, not related to any condition in the code being analyzed.

   The `ruleId` property for a `result` object whose `kind` property is `note` may be present, if the
   note relates to a particular rule; otherwise `ruleId` may be absent.
   
~ IsoExample
The first informational log entry relates to a specific rule, the second does not:
```
    ...
    "results": [
        {
            "ruleId": "ABC0001",
            "kind": "note",
            "fullMessage": "A new version of rule ABC0001 is available."
        },
        {
            "kind": "note",
            "fullMessage": "Version 11.0 of SuperLint is now available."
        }
    ]
    ...
```
~

If the `kind` property is not present, it shall be considered equivalent to the value `warning`.

### `fullMessage` property { #result-fullMessage }

A `result` object shall contain a property named `fullMessage` whose value is a string that describes the result.

The `fullMessage` property should provide sufficient details to allow an end user to resolve any problem that the result might indicate.
In particular, `fullMessage` shall include all of the following information that is available and relevant to the result:

*	Information sufficient to identify the analysis target, and the location within the target where the problem occurred.

*	The condition within the analysis target that led to the problem being reported.

*	The risks potentially associated with not fixing the problem.

*	The full range of responses to the problem that the end user could take
(including the definition of conditions where it might be appropriate not to fix the problem, or to conclude that the result is a false positive).

The first sentence of the `fullMessage` property should provide a useful summary of the result,
suitable for display in cases where UI is limited.
Tools that construct `fullMessage` in this way need not provide a value for the `shortMessage` property.
Tools that do not construct `fullMessage` in this way should provide a value for the `shortMessage` property,
because otherwise, the initial portion of `fullMessage` that a viewer displays where UI space is limited
might not be understandable.

~ IsoExample
This is an example of a `fullMessage`:
```
    "Deleting object members may compromise performance when subsequently accessing the object.
    Consider setting object member 'x' to null instead, unless this object is a dictionary
    or if runtime semantics otherwise dictate that the existence of a null member is distinct
    from one that is not present at all. This violation can also be ignored for infrequently
    called code paths."
```
~

### `shortMessage` property { #result-shortMessage }

A `result` object may contain a property named `shortMessage` whose value is a string that describes the result.
The `shortMessage` property should be a single sentence that is understandable
when visible space is limited to a single line of text.

~ IsoExample
This is an example of a `shortMessage`:
```
    "Deleting member 'x' of variable 'y' may compromise performance on subsequent accesses
    of 'y'."
```
~

### `formattedMessage` property { #result-formattedMessage }

A `result` object (&sect;[#result]) may contain a property named `formattedMessage` whose value is
a `formattedMessage` object (&sect;[#formattedMessage]) that can be used to construct
a formatted message that describes the result.

If the `formattedMessage` property is present on a `result`, the `fullMessage` property (&sect;[#result-fullMessage])
shall be absent.
If the `fullMessage` property is present on a `result`, the `formattedMessage` property
shall be absent.

### `locations` property { #result-locations }

A `result` object should contain a property named `locations` whose value is an array
of one or more `location` objects (&sect;[#location]), each of which specifies a location where the result occurred.

~ IsoNote
In rare circumstances, it might not be possible to specify a location for a result.
However, `locations` is very valuable information for anyone who needs to diagnose and correct
the condition described by the result, so the authors of analysis tools should make
every effort to provide it.
~

~ IsoNumberedExample { @IsoNumberedExample=1}
If a C++ analyzer detects that no file defines a `main` method,
then the result cannot be associated with a file.
~

The `locations` array shall not contain more than one element unless the problem indicated by the result, if any, can only be corrected
by making a change every location specified in the array.

~ IsoNumberedExample
In programming languages that support partial classes,
the name of a single class may occur more than once in the source code.
If an analysis tool reported that the name of such a class did not conform to a specified convention,
then the resulting log file should contain a single result object,
which should contain a locations array each of whose elements specifies the location in the source code
where the class name occurs.
~

The `locations` array shall not be used to specify distinct occurrences of the same result,
which can be corrected independently.

~ IsoNumberedExample
Consider an analysis tool which locates misspelled words in documentation,
and suppose this tool scans a document in which the same word is misspelled in two distinct locations.
Then the resulting log file should contain two distinct `result` objects,
each of which should contain a `locations` array containing a single `location` object
specifying the location of one instance of the misspelled word.

In contrast, consider a tool which locates misspelled words in variable names.
If the tool detects a misspelled variable name, it should produce a single `result` object whose
`locations` array contains the location of every reference to the variable,
since fixing some but not all of the references would cause a compilation error.
~

### `toolFingerprint` property { #result-toolFingerprint }

A `result` object may contain a property named `toolFingerprint` whose value is a string
that contributes to the unique identity of the result.
[Annex A](#Annex-A) explains how a result management system can use this value.

### `codeFlows` property { #result-codeFlows }

A `result` object may contain a property named `codeFlows` whose value is an array of
`codeFlow` objects (&sect;[#codeFlow]).
The `codeFlows` property is intended for use by analysis tools that provide execution path
details that illustrate a possible problem in the code.
We refer to this execution path as a code flow.
Each `codeFlow` object in the `codeFlows` array shall describe a single code flow.

~ IsoNote
The SARIF file format allows multiple code flows within a single `result` object
to allow for the possibility that more than one path through the program might be
relevant to a single result.
~

### `stacks` property { #result-callStacks }

A `result` object may contain a property named `stacks` whose value is an array of arrays of
`annotatedCodeLocation` objects (&sect;[#annotatedCodeLocation]).
For convenience, in this context we refer to an array of `annotatedCodeLocation` objects as a `stack` object;
hence we may say that the value of the `stacks` property is an array of `stack` objects.
The `stacks` property is intended for use by analysis tools that collects call stack information 
in the process of producing results.

Each `stack` object in the stacks array shall describe a single call stack.
A call stack is a sequence of nested function calls.
A stack is in turn represented by an array of `annotatedCodeLocation` objects.
This array shall include every function call in the stack for which the tool has information,
and the entries that are present shall occur in order with the innermost call first and the outermost call last.

~ IsoNumberedNote { @IsoNumberedNote=1}
The SARIF file format allows multiple call stacks within a single `result` object
to allow for the possibility that more than one call stack might be relevant to a single result.
~

~ IsoNumberedNote
It is possible that the analysis tool will not have location information for every call in the call stack.
This might happen, for example, if application code for which location information is available calls into operating system code
for which location information is not available, which in turn calls back into application code.
~

### `relatedLocations` property { #result-relatedLocations }

A `result` object may contain a property named `relatedLocations` whose value is an array
of one or more `annotatedCodeLocation` objects (&sect;[#annotatedCodeLocation]),
each of which represents a location relevant to understanding the result.

~ IsoExample
Suppose that a tool for analyzing JavaScript has a rule that reports a problem
when a variable declared in an inner scope hides a variable with the same name in an enclosing scope.
The tool would report the problem on the line where the inner variable is declared.
The tool could choose to add an element to the `relatedLocations` array, specifying
the location where the outer variable was declared.

The result might appear in the log file like this:

```
results: [
    {
        "ruleId": "JS3056",
        "kind": "error",
        "shortMessage": "Name 'index' cannot be used in this scope because it would give a different meaning to 'index'.",

        "locations": [
            {
                "analysisTarget": [
                    {
                        "uri": "file:///C:/Code/a.js",
                        "region": {
                            "startLine": "6",
                            "startColumn": "10"
                        }
                    }
                ]
            }
        ],

        "relatedLocations": [           # An array of annotatedCodeLocation objects (see \(&sect;[#annotatedCodeLocation]\))
            { 
                "message": "The previous declaration of 'index' was here.",
                "physicalLocations": [
                    [
                        {
                            "uri": "file:///C:/Code/a.js",
                            "region": {
                                "startLine": "2",
                                "startColumn": "6"
                            }
                        }
                    ]
                ]
            }
        ]
    },
    ...
]
```

The tool might write messages to the console like this:

```
C:\Code\a.js(6,10-10) : error : JS3056: Name 'index' cannot be used in this scope because it would give a different meaning to 'index'.
C:\Code\a.js(2,6-6) : info : JS3056: The previous declaration of 'index' was here.
```

~

### `isSuppressedInSource` property { #result-isSuppressedInSource }

A `result` object may contain a property named `isSuppressedInSource` whose value is one of the strings
`"true"` or `"false"`.

Some programming languages offer a syntactic construct for suppressing compiler warnings.
For tools that examine source code written in such a language, this value shall be set to `"true"`
if the tool determines that the result occurred at a location within the scope of an instance of such a construct
which is intended to suppress that particular class of result.
It shall be set to `"false"` if the tool determines that the result did not occur at such a location.
It shall be absent if the tool cannot or chooses not to determine whether the result occurred at such a location.

For tools that do not examine source code written in such a language, this value shall be absent.

~ IsoExample
The `#pragma` warning construct in C# is such a syntactic construct.
~

### `fixes` property { #result-fixes }

A `result` object may contain a property names `fixes`, whose value is a JSON array of zero or more `fix` objects (&sect;[#fix]).

### `tags` property { #result-tags }

A `result` object may contain a property named `tags`, whose value is a tag set.

### `properties` property { #result-properties }

A `result` object may contain a property named `properties`, whose value is property bag.
This allows tools to include information about the result that is not explicitly specified in the SARIF format.

## `location` object { #location }

### General { #location-General }

A `location` object specifies the location where an analysis tool produced a result.
A `location` object should specify the physical location (&sect;[#physicalLocation]) of the result,
and it may also specify the logical location (&sect;[#location-fullyQualifiedLogicalName]) of the result.

A logical location specifies a programmatic construct, for example, a class name or a function name,
without specifying the programming artifact within which that construct occurs.

~ IsoNote
There are two reasons to include logical locations in the SARIF format in addition to physical locations:
    
1. In the absence of symbol information, binary analysis tools might not have source code locations available,
    so information about line and column numbers might not be present in the log file.
    In this case, code editors, other programs, or end users can use logical location to navigate from a result to the correct
    source code location.

2. Logical location information is an important contributor to fingerprinting scenarios,
    because it is typically more resilient to changes in source code than are line locations.
    See Annex A for more information about fingerprinting.
    The `fullyQualifiedLogicalName` property (&sect;[#location-fullyQualifiedLogicalName])
    is particularly convenient for fingerprinting.
~

### Constraints { #location-Constraints }

Depending on the information available to the tool that produces the SARIF log file,
either or both of the `analysisTarget` property (&sect;[#location-analysisTarget]) and the
`resultFile` property (&sect;[#location-resultFile]) shall be present.

If the tool that produces the log file knows the analysis target, then the `analysisTarget`
property shall be present.
If the tool knows that the result file is different from the analysis target,
then the `resultFile` property shall be present;
otherwise the `resultFile` property shall be absent.

~ IsoNote
Generally, an analysis tool will know both the file it was instructed to scan
(the analysis target) and the file in which it detects a problem (the result file).
~

~ IsoNumberedExample { @IsoNumberedExample=1 }
Suppose an analysis tool for C++ source code is instructed to scan the source file _a.cpp_,
and suppose the tool detects a problem in _a.cpp_.
In this case, the tool should set the `analysisTarget` property to `a.cpp`,
and it should not set the `resultFile` property.
~

~ IsoNumberedExample
Suppose an analysis tool for C++ source code is instructed to scan the source file _a.cpp_,
which includes the header file _b.h_,
and suppose the tool detects a problem in _b.h_.
In this case, the tool should set the `analysisTarget` property to `a.cpp`,
and it should set the `resultFile` property to `b.h`.
~

~ IsoNumberedExample
Suppose an analysis tool for object code detects a problem in the binary file _c.dll_,
and suppose the tool has available symbol information which maps that location within the binary
to a specific line in a source file _d.cpp_.
In this case, the tool should set the `analysisTarget` property to `c.dll`,
and it should set the `resultFile` property to `d.cpp`.
~

If the tool that produces the log file does not know the analysis target,
then the `resultFile` property shall be present and the `analysisTarget` property shall be absent.

~ IsoNote
Some analysis tools produce output in a format that does not include both the
analysis target and the result file.
In such cases, a conversion tool which translates the output into the SARIF format
might only have the result file available. 
~

~ IsoExample
Suppose an analysis tool for C++ source code is instructed to scan the source file _a.cpp_,
which includes the header file _b.h_,
and suppose the tool detects a problem in _b.h_.
Suppose further that the tool produces output in a format other than SARIF, for example:

```
{ "file": "b.h", "line": 6, "column" 1, "Uninitialized variable" }
```

Suppose a conversion tool attempts to translate this output into SARIF format.
Suppose that the conversion tool does not know whether the analysis tool was instructed
to scan a source file that included _b.h_, or whether it was instructed to scan _b.h_ directly.
In this case, the conversion tool only knows that the problem occurred in _b.h_.
The conversion tool should set the `resultFile` property to `b.h`,
and it should not set the `analysisTarget` property. 
~

### `analysisTarget` property { #location-analysisTarget }

A `location` object may contain a property named `analysisTarget` whose value is a `physicalLocation` object (&sect;[#physicalLocation])
that identifies the file that the analysis tool was instructed to scan.
This need not be the same as the file where the result actually occurred. See `resultFile` (&sect;[#location-resultFile]) for more information on this point.

Whether `analysisTarget` is present depends on the information available to the tool that produces the log file
(see &sect;[#location-Constraints]).

### `resultFile` property { #location-resultFile }

A `location` object may contain a property named `resultFile` whose value is a `physicalLocation` object (&sect;[#physicalLocation])
that identifies the file where the analysis tool produced the result.

Whether `resultFile` is present depends on the information available to the tool that produces the log file
(see &sect;[#location-Constraints]).

### `fullyQualifiedLogicalName` property { #location-fullyQualifiedLogicalName }

A `location` object may contain a property named `fullyQualifiedLogicalName` whose value is a string
which specifies the fully qualified name of the logical location where the analysis tool produced the result.

The format of the `fullyQualifiedLogicalName` string shall be consistent with the programming language
in which the programmatic construct specified by that logical location was expressed.

~ IsoNumberedExample { @IsoNumberedExample=1 }
C: `create_process`
~
~ IsoNumberedExample
C++: `Namespace::Class::Method(int, double) const &&`
~
~ IsoNumberedExample
C#: `Namespace1.Namespace2.Class.Method(System.String, int[])`
~

If the `run.logicalLocations` property (&sect;[#run-logicalLocations]) is present,
the value of the `fullyQualifiedLogicalName` property should be equal to the name of one of the properties on the `run.logicalLocations` object,
with one exception, described in &sect;[#location-logicalLocationKey].

~ IsoNote
There are a few reasons the `fullyQualifiedLogicalName` property exists,
even though the information it contains is presented in more detail in the `run.logicalLocations` property.

1. It allows a result log viewer to display the logical location in a way that is easily understood by users.

2. As mentioned in &sect;[#location-General], `fullyQualifiedLogicalName` is also particularly convenient
for fingerprinting, although the more detailed information in `run.logicalLocations` could be used instead.

3. It relieves viewers from having to format the logical location from the more detailed
information in `run.logicalLocations`.

4. It is useful for producing readable in-source suppressions (for example, "suppress all instance of rule `CA2101`
    in the class `NamespaceA.NamespaceB.ClassC`").
~

### `logicalLocationKey` { #location-logicalLocationKey }

The `location` object may contain a property named `logicalLocationKey` whose value is a string.
If present, this string shall be equal to the name of one of the properties on the `run.logicalLocations` object (&sect;[#run-logicalLocations]),
which provides additional information about the logical location specified by `fullyQualifiedLogicalName` (&sect;[#location-fullyQualifiedLogicalName]).

`logicalLocationKey` is only necessary if, in the course of a run, the tool produces results in two or more
distinct logical locations with the same `fullyQualifiedLogicalName`.
In that case, the tool shall synthesize a unique name by appending a suffix to `fullyQualifiedLogicalName`,
assign the resulting string to `logicalLocationKey`, and use that string as the key into the `run.logicalLocations` dictionary.

~ IsoExample
Suppose a tool analyzes two C++ source files:

```
// file1.cpp
namespace A {
    class B {
    }
}

// file2.cpp
namespace A {
    namespace B {
        class C {
        }
    }
} 
```

(These could not coexist in the same compilation, but there is no reason two such source files could not exist.)

If the tool produced one result in class `B` in file1.cpp, and another result in namespace `B` in file2.cpp,
the `fullyQualifiedLogicalName` for both would be `A::B`.
In that case, the tool might set the `logicalLocationKey` property in either one of the results to `A::B-0`,
and it might populate the `logicalLocations` property as follows:

```
"logicalLocations": {
  "A::B": [
    {
      "name": "A",
      "kind": "namespace"
    },
    {
      "name": "B",
      "kind": "namespace"
    }
  ],
  "A::B-0": [
    {
      "name": "A",
      "kind": "namespace"
    },
    {
      "name": "B",
      "kind": "type"
    }
  ]
}
```
~

### `tags` property { #location-tags }

A `location` object may contain a property named `tags`, whose value is a tag set.

### `properties` property { #location-properties }

A `location` object may contain a property named `properties`, whose value is a property bag.
This allows tools to include information about the location that is not explicitly specified in the SARIF format.

## `physicalLocation` object { #physicalLocation }

### General { #physicalLocation-General }

A `physicalLocation` object represents the physical location where a result was detected.
A physical location specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.

### `uri` property { #physicalLocation-uri }

A `physicalLocation` object shall contain a property named `uri` whose value is a string that represents
the location of the file as a valid URI.

If the `run.files` property (&sect;[#run-files]) is present, the value of the `uri` property should be equal to
the name of one of the properties on the `run.files` object,
which provides additional information about the file specified by `uri`.

~ IsoExample

```
{
  "version": "1.0",
  "runs": [
    {
      "run": {
        "files": {
          "file:///C:/Code/main.cc": [
            {
              "mimeType": "text/x-c",
            }
          ]
        }
      },
      
      "results": [
        {
          "ruleId": "CA2101",
          "kind": "error",
          "locations": [
            {
              "resultFile": {
                "uri": "file:///C:/Code/main.cc",
                "region: {
                  "startLine": 24,
                  "startColumn": 9
                }
              }
            }
          ]
        }
      ]
    }
  ]
}
```

~

### `region` property { #physicalLocationComponent-region }

A `physicalLocation` object may have a property named `region` whose value is a `region` object (&sect;[#region]),
that represents the region within a file where the result was detected.

If the result occurs in a nested file, then the `region` property shall specify the location of the result
with respect to the innermost nested file.

~ IsoExample
If a result occurs in a C++ file contained in a compressed archive, then the region would represent
the line and column number of the result with the C++ file.
It would not represent (for example) the offset of the C++ file from the start of the archive.
~

## `region` object { #region }

### General { #region-General }

A `region` object represents a region, that is, a contiguous portion of a file.
Every property in a `region` object shall be represented by a non-negative integer,
that is, by a JSON number value with no sign, no fractional part, and no exponent part.

SARIF defines two types of regions: text regions and binary regions.

* A text region represents a contiguous range of of zero or more characters.
* A binary region represents a contiguous range of zero or more bytes.

SARIF defines different properties to represent text regions and binary regions.

In a text region, the `startLine` property (&sect;[#region-startLine])
shall be present and have a value greater than 0.
In a binary region, the `startLine` property shall be absent. 

~ IsoNumberedNote { @IsoNumberedNote=1 }
Consumers of SARIF files can use the presence or absence of the `startLine` property to
determine whether to treat a region as a text region or as a binary region.
~

~ IsoNumberedNote
It is up to each analysis tool whether to treat a given file as a text file
(in which case it would emit text regions for results detected in the file)
or as a binary file
(in which case it would emit binary regions).
~

### Text regions { #region-textFiles }

The line number of the first line in a text region shall have the value `1`.
The column number of the first character in each line shall have the value `1`.

~ IsoNote
SARIF defines column number as a count of characters.
If a line in a text file contains tab characters, viewers may choose to present column
numbers that match the visual offset of each character from the beginning of the line.
These "visual" column numbers will not match the column numbers contained in the SARIF file.
~

Depending on the file's character encoding, each character might be represented by one byte or by multiple bytes.
In source files encoded in UTF-16, characters outside the Basic Multilingual Plane (BMP)
are represented as a sequence of two 16-bit code points;
this sequence is called a "surrogate pair."
Tools that report results in UTF-16-encoded files shall consider characters outside the BMP
as occupying two columns.

~ IsoNumberedNote { @IsoNumberedNote=1 }
The reason for this requirement is that is common for existing tools to ignore surrogate pairs
when calculating column numbers.
~

~ IsoNumberedNote
Programs such as viewers that process SARIF log files together with the analysis target files
to which those log files refer should attempt to determine the character encoding of the target files.
In the absence of internal information such as a Byte Order Mark, viewers may use external information
(for example, command line arguments, project settings, or other configuration information)
to determine the character encoding.
If external information is also lacking, viewers should assume that each character occupies one byte.
~

The start of a text region shall be represented by a combination of the `startLine` (&sect;[#region-startLine])
and `startColumn` (&sect;[#region-startColumn]) properties.
`startLine` shall be present.
If `startColumn` is absent, the region shall be considered to start at column 1.
For the remainder of this section, whenever `startColumn` is mentioned, it includes the case where `startColumn` is absent
and so is considered to be 1.

The end of a text region shall be represented either by a combination of the `endLine`
(&sect;[#region-endLine]) and `endColumn` (&sect;[#region-endColumn]) properties,
or by the `length` property (&sect;[#region-length]).

If `endLine` is absent and `endColumn` is present, `endLine` shall be considered to be the same as `startLine`.

If `endLine` is present and `endColumn` is absent, then:

* if `endLine` is the same as `startLine`, then `endColumn` shall be considered to be the same as `startColumn`.

* If `endLine` is different from `startLine`, then `endColumn` shall be considered to be 1.

For the remainder of this section, whenever `endLine` is mentioned, it includes the case where `endLine` was absent
and so is considered to be the same as `startLine`.

For the remainder of this section, whenever `endColumn` is mentioned, it includes the case where
`endColumn` was absent and so has its default value, which depends on the value of `endLine`
as described above.

If `endLine` is the same as `startLine` and `startColumn` is the same as `endColumn`,
the length of the region shall be considered to be 0.

If `length` is present, it shall be non-negative and shall represent a count of characters.

If none of `endLine`, `endColumn`, or `length` is present, the length of the region shall be considered to be 0.

`endLine` shall be greater than or equal to `startLine`.

If `endLine` is equal to `startLine`, then `endColumn` shall be greater than or equal to `startColumn`.

To represent a region that includes the last character in a line,
excluding any trailing newline sequence,
`endColumn` shall be set to a value 1 greater than the number of characters in the line,
excluding the newline sequence if present.
This is the case even for the last line of the file, which might not end with a newline sequence.

~ IsoExample
Suppose a text file contains the following line, on line 5:

```
abcde
```

Then the region with `startLine` = 5, `startColumn` = 3, `endLine` = 5, and `endColumn` = 6
represent the three characters `cde`.
This is the case whether or not the line ends with a newline sequence.
~

To include a newline sequence in a region, `endLine` must be greater than `startLine`.

~ IsoExample
Suppose a text file contains the following lines, starting on line 5:

```
abcde
fg
```

Then the region with `startLine` = 5, `startColumn` = 3, `endLine` = 6, and `endColumn` = 1
represent the three characters `cde` plus a newline sequence.
~

### Binary regions { #region-binaryFiles }

The start of a binary region shall be represented by the `offset` property (&sect;[#region-offset]),
which denotes the offset in bytes from the start of the file.

The offset of the first byte in a file shall have the value 0.

The end of a binary region shall be represented by the `length` property (&sect;[#region-length]),
which denotes a count of bytes. If `length` is absent, the length of the region shall be considered to be 0.

In a binary region, the `startLine` (&sect;[#region-startLine]), `startColumn` (&sect;[#region-startColumn]),
`endLine` (&sect;[#region-endLine]), and `endColumn` (&sect;[#region-endColumn])
properties shall be absent.

### `startLine` property { #region-startLine }

When a `region` object represents a text region, it shall contain a property named `startLine`,
which shall have an integer value equal to the line number of the line containing the first character in the region.

The line number of the first line in the file is defined to be 1.

### `startColumn` property { #region-startColumn }

When a `region` object represents a text region, it may contain a property named `startColumn`,
which shall have an integer value equal to the column number of the first character in the region.

The column number of the first column on each line is defined to be 1.

If `startColumn` is absent, it shall be inferred as specified in &sect;[#region-textFiles].

### `endLine` property { #region-endLine }

When a `region` object represents a text region,
it may contain a property named `endLine` which shall have an integer value equal to
the line number of the line containing the last character in the region.

If `endLine` is absent, it shall be inferred as specified in &sect;[#region-textFiles].

### `endColumn` property { #region-endColumn }

When a `region` object represents a text region,
it may contain a property named `endColumn` which shall have an integer value equal to
the column number of the last character in the region.

If `endColumn` is absent, it shall be inferred as specified in  &sect;[#region-textFiles].

### `offset` property { #region-offset}

When a `region` object represents a binary region,
it shall contain a property named `offset` which shall have an integer value equal to
the byte offset from the beginning of the file of the first byte in the region.

When a `region` object represents a text region, the `offset` property may be present.
In this case, it represents the character offset from the beginning of the file of the first
character in the region.

### `length` property { #region-length }

A `region` object may have a property named `length` whose value is a non-negative integer.

When the `region` object represents a text region,
the value of `length` shall  the number of characters in the region.
If the region consists of 0 characters, then `length` shall either be absent or shall have the value 0.

When a `region` object represents a binary region,
the value of `length` shall be the number of bytes in the region.
If the region consists of 0 bytes, then `length` shall either be absent or shall have the value 0.

The sum of the `offset` (&sect;[#region-offset]) and `length` properties shall be greater than or equal to 0,
and less than or equal to the length the file, which is measured in characters for a text region
and in bytes for a binary region.

A `region` whose `offset` is equal to the length of the file and whose `length` is 0 legal,
and represents an insertion point at the end of the file.

## `logicalLocationComponent` object { #logicalLocationComponent }

### General { #logicalLocationComponent-General }

A `logicalLocationComponent` object describes a component of a logical location.

`logicalLocationComponent` objects occur as members of arrays within the `run.logicalLocations` object (&sect;[#run-logicalLocations]).

### `name` property { #logicalLocationComponent-name }

A `logicalLocationComponent` object shall contain a property named `name`, whose value shall be a string that identifies
the construct in which the result occurred.
For example, this property might contain the name of a class or a method.

The `name` property need not be suitable for display.

~ IsoExample
A C++ analysis tool might emit the `name` property of a function as the "decorated" function name,
which encodes the function signature in a manner that is compiler-dependent and not easily readable.
~


If the `logicalLocationComponent` object occurs as the only member of an array within
the `run.logicalLocations` object (&sect;[#run-logicalLocations]),
and if the `name` property would be equal to the name of the corresponding property, then the `name` property may be absent.

~ IsoNumberedExample { @IsoNumberedExample=1 }
In this example, the array of `logicalLocationComponent` objects has only one element, and `name` is omitted.
```
"logicalLocations": {
  "functionF": [
    {
      "kind": "function"
    }
  ]
}
```
~

~ IsoNumberedExample
In this example, the array of `logicalLocationComponent` objects has only one element, and `name` is equal to the property name.
```
"logicalLocations": {
  "functionF": [
    {
      "name": "functionF",
      "kind": "function"
    }
  ]
}
```
~

~ IsoNumberedExample
In this example, the array of `logicalLocationComponent` objects has only one element,
but `name` is not equal to the property name, so it cannot be omitted.
```
"logicalLocations": {
  "functionF-0": [
    {
      "name": "functionF",
      "kind": "function"
    }
  ]
}
```
~

### `kind` property { #logicalLocationComponent-kind }

A `logicalLocationComponent` object should contain a property named `kind`, whose value shall be one of the following strings,
if any of those strings accurately describes the construct identified by this object:

*   `function`
*   `member`
*   `method`
*	`module`
*	`namespace`
*	`package`
*	`resource`
*	`type`

If none of those strings accurately describes the construct, `kind` may contain any value specified by the analysis tool.

## `codeFlow` object { #codeFlow }

### General { #codeFlow-General }

A code flow is a sequence of locations that specify a possible execution path through the code.

### `message` property { #annotatedCodeLocation-message }

A `codeFlow` object may contain a property named `message` whose value is a string containing
a message relevant to the code flow.

### `locations` property { #codeFlow-locations }

A `codeFlow` object shall contain a property named `locations` whose value is an array of
one or more `annotatedCodeLocation` objects (&sect;[#annotatedCodeLocation]).
Each element of the array shall represent a single location visited by the tool
in the course of producing the result.
This array need not include every location visited by the tool,
but the elements that are present shall occur in the order that the tool visited them.
The elements need not be unique.

~ IsoNote
The `locations` array might include multiple identical elements if, for example,
the analysis tool simulated the execution of a loop in the course of producing the result.
~

### `tags` property { #codeFlow-tags }

A `codeFlow` object may contain a property named `tags`, whose value is a tag set.

### `properties` property { #codeFlow-properties }

A `codeFlow` object may contain a property named `properties`, whose value is a property bag.
This allows tools to include information about the code flow that is not explicitly specified in the SARIF format.

## `annotatedCodeLocation` object { #annotatedCodeLocation }

### General { #annotatedCodeLocation-General }

An `annotatedCodeLocation` object is an element of an `codeFlow` object (&sect;[#result-codeFlows]),
a `stack` object (&sect;[#result-callStacks]),
or the `relatedLocations` array (&sect;[#result-relatedLocations]).

### `physicalLocation` property { #annotatedCodeLocation-physicalLocation }

An `annotatedCodeLocation` object must contain a property named `physicalLocation` whose value is a `physicalLocation` object
(&sect;[#physicalLocation]) that specifies the file location to which the `annotatedCodeLocation` object refers.

### `message` property { #annotatedCodeLocation-message }

An `annotatedCodeLocation` object may contain a property named `message` whose value is a string that describes
the significance of this entry within the overall code flow.
For example, if the `annotatedCodeLocation` refers to an `if` statement, the `message` property might contain the string "take true branch".

### `tags` property { #annotatedCodeLocation-tags }

An `annotatedCodeLocation` object may contain a property named `tags`, whose value is a tag set.

### `properties` property { #annotatedCodeLocation-properties }

An `annotatedCodeLocation` object may contain a property named `properties`, whose value is a property bag.
This allows tools to include information about the location that is not explicitly specified in the SARIF format.

## `rule` object { #rule }

### General { #rule-General }

A `rule` object contains information that describes a rule.

### Constraints

Either the `shortDescription` property (&sect;[#rule-shortDescription])
or the `fullDescription` property (&sect;[#rule-fullDescription])
or both must be present.

### `id` property { #rule-id }

A `rule` object shall contain a property named `id` whose value is a string containing
a stable, opaque identifier for the rule.

~ IsoExample
`"CA2101"`
~

### `name` property { #rule-name }

A `rule` object may contain a property named `name` whose value is a string containing
a rule identifier that is understandable to an end user.
If `name` contains implementation details that change over time,
a tool author might alter a rule's `name` (while leaving
the stable `id` property unchanged).

~IsoNote
A rule `name` is suitable in contexts where a readable identifier is preferable and where the
lack of stability is not a concern.
~

~ IsoExample
`"SpecifyMarshalingForPInvokeStringArguments"`
~

### `shortDescription` property { #rule-shortDescription }

A `rule` object may contain a property named `shortDescription` whose value is a string containing
a concise description of the rule. The `shortDescription` property should be a single sentence that is understandable
when visible space is limited to a single line of text.

~ IsoExample
`"Specify marshaling for P/Invoke string arguments"`
~

### `fullDescription` property { #rule-fullDescription}

An `rule` object should contain a property named `fullDescription` whose value is a string that describes the rule.

The `fullDescription` property should, as far as possible, provide details sufficient to enable resolution of any problem indicated by the result. 

The first sentence of the `fullDescription` property should provide a concise description of the rule,
suitable for display in cases where available space is limited.
Tools that construct `fullDescription` in this way need not provide a value for the `shortDescription` property.
Tools that do not construct `fullDescription` in this way should provide a value for the `shortDescription` property,
because otherwise, the initial portion of `fullDescription` that a viewer displays where available space is limited
might not be understandable.

### `options` property { #rule-options }

A `rule` object may contain a property named `options`, whose value is a JSON object
consisting of a set of name/value pairs with arbitrary names.
The `options` objects shall describe the set of configurable options supported by the rule.

The value within each name/value pair shall be a string, which may be the empty string.
The value shall not be a JSON array or sub-object.

### `messageFormats` property { #rule-messageFormats }

A `rule` object may contain a property named `messageFormats`, whose value is a JSON object
consisting of a set of name/value pairs with arbitrary names.

The value within each name/value pair shall be a string, which we refer to as a "message format,"
that can be used to construct a formatted message in combination with
an arbitrary number of additional strings, which we refer to as "arguments" (see &sect;[#formattedMessage-arguments]).

A message format shall consist of plain text interspersed with zero or more placeholders.
Each placeholder shall be of the form "`{`_n_`}`", where _n_ is a non-negative integer
which represents a 0-based index into the list of arguments.
When a viewer or other program displays a message whose format is specified by a
message format, it shall replace every occurrence of the placeholder `{`_n_`}`
with the string value at index _n_ in the list of arguments.
Within a message format, the characters "`{`" and "`}`" shall be represented by
the character sequences "`{{`" and "`}}`" respectively.

~ IsoExample
Given a message format:
```
The variable "{0}" defined on line {1} is never used. Consider removing "{0}".
```
together with the arguments "`x`" and "`12`", a viewer would display the formatted string
```
The variable "x" defined on line 12 is never used. Consider removing "x".
```
~

The set of names appearing in the `messageFormats` property shall contain at least the set of strings
which occur as values of the `result.formattedMessage.formatId` property in the result log.
The `messageFormats` property may contain additional name/value pairs whose names do not appear
as the value of the `result.formattedMessage.formatId` property for any result in the result log.

~IsoNote
Additional name/value pairs are permitted in the `messageFormats` property
for the convenience of tool vendors, who might find it easier to emit the entire set of messages
supported by a rule, rather than restricting it to those messages that happen to appear in the
result log.
~

~ IsoExample

````
{
    "objectCreation" : "{0} creates a new instance of {1} which is never used.
	                    Pass the instance as an argument to another method, assign the instance to a variable,
						or remove the object creation if it is unnecessary.",  
    "stringReturnValue" : "{0} calls {1} but does not use the new string instance that the method returns.
	                       Pass the instance as an argument to another method, assign the instance to a variable,
						  or remove the call if it is unnecessary."        
}
````
~

### `helpUri` property { #rule-helpUri }

A `rule` object may contain a property named `helpUri`, whose value is a string
containing the URI where the primary documentation for the rule can be found.

~ IsoNote
The documentation might include examples, contact information for the rule authors,
and links to additional information about the rule.
~

### `tags` property { #rule-tags }

A `rule` object may contain a property named `tags`, whose value is a tag set.

### `properties` property { #rule-properties }

A `rule` object may contain a property named `properties`, whose value a property bag.
This allows tools to include information about the rule that is not explicitly specified in the SARIF format.

## `formattedMessage` object { #formattedMessage }

### General { #formattedMessage-General }

A `formattedMessage` object contains information that can be used to construct a formatted message that describes a result.

### `formatId` property { #formattedMessage-id }
A `formattedMessage` object must contain a property named `formatId`, whose value is a string that identifies the message format
used to format the message that describes this result.
The value of `formatId` must correspond to one of the names in the set of name/value pairs contained in the `messageFormats` property (&sect;[#rule-messageFormats])
of the `rule` object (&sect;[#rule]) whose `id` property (&sect;[#rule-id]) matches the `ruleId` property (&sect;[#result-ruleId]) of this result.

### `arguments` property { #formattedMessage-arguments }
A `formattedMessage` object may contain a property named `arguments`,
whose value is an array of string values that will be used, in combination with a message format,
to construct a result message.

## `fix` object { #fix }

### General { #fix-General }

A `fix` object represents a proposed fix for the problem indicated by the `result` object (&sect;[#result]) in which it occurs.
It specifies a set of files to modify.
For each file, it specifies which bytes to remove, and provides new bytes to be inserted.

~IsoExample

````
    {                                                     # a result object (see \(&sect;[#result]\))
        "fix":
        {
            "description":                                # see \(&sect;[#fix-description]\)
                "Private member names begin with '_'",
            "fileChanges":                                # see \(&sect;[#fix-fileChanges]\)
            [
                {                                         # a fileChange object (see \(&sect;[#fileChange]\))
                    ...
                }
            ]
        }
    }
````

~

### `description` property { #fix-description }

A `fix` object may contain a property named `description` whose value is a string describing the proposed fix.

~IsoNote
The purpose of the `description` property is to enable a result log viewer to present the proposed fix to the end user.
~

~IsoExample
`"Combine declaration and initialization of variable x"`
~

### `fileChanges` property { #fix-fileChanges }

A `fix` object shall contain a property named `fileChanges` whose value is a JSON array of
`fileChange` objects (&sect;[#fileChange]).
The array shall contain at least one element.

~IsoNote
A `fix` object that does not change any files is not meaningful.
~

## `fileChange` object { #fileChange }

### General { #fileChange-General }

A `fileChange` object represents a change to a single file.

~IsoExample

````
    {                                      # a fix object (see \(&sect;[#fix]\))
        "fileChanges":                     # see \(&sect;[#fix-fileChanges]\)
        [
            {                              # a fileChange object
                "uri": "a.h",              # see \(&sect;[#fileChange-uri]\)
                "replacements":            # see \(&sect;[#fileChange-replacements]\)
                [
                    {                      # a replacement object (see \(&sect;[#replacement]\))
                        ...
                    },
                    {                      # another replacement object.
                        ...
                    }
                ]
            }
        ]
    }

````

~

### `uri` property { #fileChange-uri }

A `fileChange` object shall contain a property named `uri` whose value is a string value that represents
the location of the file as a valid URI.

### `replacements` property { #fileChange-replacements }

A `fileChange` object shall contain a property named `replacements` whose value is a JSON array of
`replacement` objects (&sect;[#replacement]),
each of which represents the replacement of a single range of bytes in the file specified by the
`uri` property (&sect;[#fileChange-uri]).
The array shall contain at least one element.

~IsoNote
A `fileChange` object that does not modify any bytes in the file is not meaningful.
~

## `replacement` object { #replacement }

### General { #replacement-General }

A `replacement` object represents the replacement of a single range of bytes in a file.
It specifies the location within the file where the replacement is to be made,
the number of bytes to remove at that location,
and a sequence of bytes to insert at that location.

If a `replacement` object specifies both the removal of a byte range
by means of the `deletedLength` property (&sect;[#replacement-deletedLength])
and the insertion of a sequence of bytes
by means of the `insertedBytes` property (&sect;[#replacement-insertedBytes]),
then the effect of the replacement shall be as if the removal were performed before the insertion.

If a single `fileChange` object (&sect;[#fileChange]) specifies more than one `replacement`,
then the effect of the replacements shall be as if they were performed
in the order they appear in the `replacements` array (&sect;[#fileChange-replacements]).
The `offset` property (&sect;[#replacement-offset]) of each `replacement` shall specify
an offset in the unmodified file.

~IsoExample

Suppose a `fileChange` object contains a `fileChanges` property whose value is the following
array of two `replacement` objects:

````
    "fileChanges":
    [
        {
            "offset": 12,
            "deletedLength": 5,
            "insertedBytes": "ZXhhbXBsZQ=="   # The string "example"
        },

        {
            "offset": 20,
            "deletedLength": 3
        }
    ]
````

The first `replacement` object removes 5 bytes starting at offset 12; that is, it removes bytes 12&ndash;16.
Then it inserts 7 bytes (the UTF-8-encoded string `example`, itself encoded in MIME Base64)
at the same offset.

The second `replacement` object removes 3 bytes starting at offset 20 _with respect to the
unmodified file_. Since 5 bytes were removed and 7 bytes inserted _before_ byte 20, the
3 bytes removed actually start at byte 22.

~

### Constraints { #replacement-Constraints }

In any `replacement` object, either the `deletedLength` property (&sect;[#replacement-deletedLength])
shall be present and have a value greater than 0,
or the `insertedBytes` property (&sect;[#replacement-insertedBytes])
shall be present and have a string value whose length is greater than zero,
or both.

~IsoNote
A `replacement` object in which the `deletedLength` property was absent or had a value of 0,
and in which the `insertedBytes` property was absent or had a value equal to the empty string,
would neither insert nor remove any bytes, and so would not be meaningful.
~

### `offset` property { #replacement-offset }

A `replacement` object shall contain a property named `offset`, whose value shall be a non-negative
integer specifying the offset in bytes from the beginning of the file at which bytes are to be removed,
inserted, or both.
An offset of 0 shall denote the first byte in the file.

### `deletedLength` property { #replacement-deletedLength }

A `replacement` object may contain a property named `deletedLength`, whose value is a
non-negative integer specifying the number of bytes to delete,
starting at the byte offset specified by
the `offset` property (&sect;[#replacement-offset]),
measured from the beginning of the file.

If `deletedLength` is not present, or if its value is 0,
no bytes shall be deleted.

### `insertedBytes` property { #replacement-insertedBytes }

A `replacement` object may contain a property named `insertedBytes`, whose value is a string
that specifies the byte sequence to be inserted at the byte offset specified by
the `offset` property (&sect;[#replacement-offset]),
measured from the beginning of the file.

If `insertedBytes` is not present, or if its value is the empty string,
no bytes shall be inserted.

If the file into which the bytes are to be inserted is a binary file,
the value of the `insertedBytes` string shall be the MIME Base64 encoding
of the byte sequence to be inserted.

If the file into which the bytes are to be inserted is a text file,
the characters to be inserted shall first be encoded in UTF-8.
The value of the `insertedBytes` string shall be the MIME Base64 encoding
of the resulting UTF-8 byte sequence.

* TODO: Relationship between original file encoding, offset, and UTF-8 byte sequence.
* TODO: Explain responsibility of viewer/editor to match encoding.
